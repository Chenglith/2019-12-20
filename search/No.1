No.1 Combination(组合) 简单难度 17题
 题目： 电话号码的字母组合。
 九宫格键盘
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

思路：将每个数字映射成三个字母然后做组合。
不足：代码过长，不简洁，复杂度高
相关知识：如何将字母变为数字。（回想一下怎么变得，虽然和这道题没有关系）

果然可以用dfs bfs做，但我更习惯用这个

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        reflection = {'2':'abc',
                      '3':'def',
                      '4':'ghi',
                      '5':'jkl',
                      '6':'mno',
                      '7':'pqrs',
                      '8':'tuv',
                      '9':'wxyz'}
        if not digits:
            return []                          ----------注意所有的都需要检查是否为空
        n = len(digits)                        -----------本句可删除
        aws = ['']
        for num in range(n):                   ----------for num in digits
            aws = [x + y for x in aws for y in reflection[digits[num]]]        ----------------reflection[num]
        return aws
        
总结： 这种方法最关键的地方就是递归，知道字典的用法
注意：字典一个key之能对应一个value，要是想多调用的化要引入列表或者新的字典
所以{1：abc} 的意义是1对应abc三个而不是字符串。

相似题目：
三十九题
（虽然没看出来回溯和这道题目的相似性，但可能bfsdfs相似的把）
