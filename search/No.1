No.1 Combination(组合) 简单难度 17题
 题目： 电话号码的字母组合。
 九宫格键盘
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

思路：将每个数字映射成三个字母然后做组合。
不足：代码过长，不简洁，复杂度高
相关知识：如何将字母变为数字。（回想一下怎么变得，虽然和这道题没有关系）

果然可以用dfs bfs做，但我更习惯用这个

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        reflection = {'2':'abc',
                      '3':'def',
                      '4':'ghi',
                      '5':'jkl',
                      '6':'mno',
                      '7':'pqrs',
                      '8':'tuv',
                      '9':'wxyz'}
        if not digits:
            return []                          ----------注意所有的都需要检查是否为空
        n = len(digits)                        -----------本句可删除
        aws = ['']
        for num in range(n):                   ----------for num in digits
            aws = [x + y for x in aws for y in reflection[digits[num]]]        ----------------reflection[num]
        return aws
        
总结： 这种方法最关键的地方就是递归，知道字典的用法
注意：字典一个key之能对应一个value，要是想多调用的化要引入列表或者新的字典
所以{1：abc} 的意义是1对应abc三个而不是字符串。

相似题目：
三十九题
（虽然没看出来回溯和这道题目的相似性，但可能bfsdfs相似的把）
三十九题： 无重复数组和为target值的列表
例如：
输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
求解 ： 一开始不能想遍历数组相加等于目标，这样得不到结果，思路应该是从减法入手，7-{数组中的每一个数}
要是0就输出所有结果，不然重复直到最后结果为0.
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        if target == []:
            result = [[]]
        for i, j in enumerate(candidates):
            if j ==target:
                result.append([j])
            elif j< target:
                p_result = self.combinationSum(candidates[i:],target- j)
                for p in p_result:
                    p.append(j)
                    result.append(p)
        return result
        
 总结： 这道题目是典型的回溯法，虽然我的code没有按照回溯法写，但是实际上是这样的。
 回溯法按照条件剪枝。
 回溯模板：：保存当前步骤，如果是一个解就输出；维护状态，使搜索路径（含子路径）尽量不重复。必要时，应该对不可能为解的部分进行剪枝(pruning)
 class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        n = len(candidates)
        res = []
        def helper(i, tmp_sum, tmp):
            if tmp_sum > target or i == n:
                return 
            if tmp_sum == target:
                res.append(tmp)
                return 
            helper(i,  tmp_sum + candidates[i],tmp + [candidates[i]])
            helper(i+1, tmp_sum ,tmp)
        helper(0, 0, [])
        return res
        
 个人比较喜欢bfs的版本，比较好理解，dfs的版本因为tmp_sum取值是什么不太清楚所以没太理解。
