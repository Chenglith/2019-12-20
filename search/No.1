No.1 Combination(组合) 简单难度 17题
 题目： 电话号码的字母组合。
 九宫格键盘
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

思路：将每个数字映射成三个字母然后做组合。
不足：代码过长，不简洁，复杂度高
相关知识：如何将字母变为数字。（回想一下怎么变得，虽然和这道题没有关系）

果然可以用dfs bfs做，但我更习惯用这个

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        reflection = {'2':'abc',
                      '3':'def',
                      '4':'ghi',
                      '5':'jkl',
                      '6':'mno',
                      '7':'pqrs',
                      '8':'tuv',
                      '9':'wxyz'}
        if not digits:
            return []                          ----------注意所有的都需要检查是否为空
        n = len(digits)                        -----------本句可删除
        aws = ['']
        for num in range(n):                   ----------for num in digits
            aws = [x + y for x in aws for y in reflection[digits[num]]]        ----------------reflection[num]
        return aws
        
总结： 这种方法最关键的地方就是递归，知道字典的用法
注意：字典一个key之能对应一个value，要是想多调用的化要引入列表或者新的字典
所以{1：abc} 的意义是1对应abc三个而不是字符串。

相似题目：
三十九题
（虽然没看出来回溯和这道题目的相似性，但可能bfsdfs相似的把）
三十九题： 无重复数组和为target值的列表
例如：
输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
求解 ： 一开始不能想遍历数组相加等于目标，这样得不到结果，思路应该是从减法入手，7-{数组中的每一个数}
要是0就输出所有结果，不然重复直到最后结果为0.
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        if target == []:
            result = [[]]
        for i, j in enumerate(candidates):
            if j ==target:
                result.append([j])
            elif j< target:
                p_result = self.combinationSum(candidates[i:],target- j)
                for p in p_result:
                    p.append(j)
                    result.append(p)
        return result
        
 总结： 这道题目是典型的回溯法，虽然我的code没有按照回溯法写，但是实际上是这样的。
 回溯法按照条件剪枝。
 回溯模板：：保存当前步骤，如果是一个解就输出；维护状态，使搜索路径（含子路径）尽量不重复。必要时，应该对不可能为解的部分进行剪枝(pruning)
 class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        n = len(candidates)
        res = []
        def helper(i, tmp_sum, tmp):
            if tmp_sum > target or i == n:
                return 
            if tmp_sum == target:
                res.append(tmp)
                return 
            helper(i,  tmp_sum + candidates[i],tmp + [candidates[i]])
            helper(i+1, tmp_sum ,tmp)
        helper(0, 0, [])
        return res
        
 个人比较喜欢bfs的版本，比较好理解，dfs的版本因为tmp_sum取值是什么不太清楚所以没太理解。
 ================================
 
 四十题：这道题和上一道题一样，唯一不同的是，这个题目用的数不能重复，所以代码和上一道题差不多，唯一不用要判断数不能重复利用，结果也不能重复。
 这道题用bfs踩了几个坑，
 先贴代码：
 class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        result= []
        if target == []:
            return [[]]
        for i,j in enumerate(candidates):
            if j ==target and [j] not in result:
                result.append([j])
            elif j<target:
                p_result = self.combinationSum2(candidates[i+1:], target-j)
                for p in p_result:
                    p.append(j)
                    p.sort()
                    if p not in result:
                        result.append(p)
        return result
第一个坑：结果表达不对，原因在append，pappendj 和result appen p 上不要画蛇添足，直接append就好，不需要【j】或者【p】。
第二个，结果有重复，所以我加了这一句 ：if p not in result:  result.append(p)
但发现还是不对，【1，1】，1 这个例子不通过，于是我又用了and j not in result: 
但是发现还不对， 后来想到结果是列表，j是元素，所以and [j] not in result:就对了。
但是时间成本很高，所以我觉得这种方便不太好，但是好理解。
切记你没用减枝那种方法就不要sort了好吗！！！
这类题目在花花酱的总结里面叫组合求和
这道题leetcode上面讲的模板：
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        if not candidates:
            return []
        candidates.sort()
        n = len(candidates)
        res = []
        
        def backtrack(i, tmp_sum, tmp_list):
            if tmp_sum == target:
                res.append(tmp_list)
                return 
            for j in range(i, n):
                if tmp_sum + candidates[j]  > target : break
                if j > i and candidates[j] == candidates[j-1]:continue
                backtrack(j + 1, tmp_sum + candidates[j], tmp_list + [candidates[j]])
        backtrack(0, 0, [])    
        return res
这里面值得借鉴的就是continue的用法，continue就是返回条件语句如果条件为真，为假不返回。
if k =4 continue 【1，2，3，4】的结果就是【1】【2】【3】。这个道理
所以这道题用continue来筛选出来相同的值不要，注意我们所有的例子都用了sort排序，而我们自己的bfs没有排序，用的是直接选然后去重的步骤。

77题组合：将一到n的数做k个组合
这道题我用之前经常用的那个方法会超时，（就是设一个列表然后调用，参考39 40 题）
人家的答案就还不错：
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []
        def backtrack(i, k, tmp):
            if k == 0:
                res.append(tmp)
                return 
            for j in range(i, n + 1):
                backtrack(j+1, k-1, tmp + [j])
        backtrack(1, k, [])
        return res
